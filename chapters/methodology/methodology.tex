\subsection{Overview}
The following text outlines the comprehensive methodology adopted to conduct a comparative analysis of mobile application development approaches using Java, Kotlin, and Dart. The primary objective of this research is to evaluate and compare the development efficiency, code maintainability, and overall quality of applications developed across these three different programming languages. The methodology is divided into two distinct but interrelated parts to achieve a robust analysis.
\par
\textbf{Part I: Identical Mobile Application Development}—This segment focuses on the practical aspect of developing an identical Kanban board application across the three selected programming frameworks. It involves setting up development environments, detailing the application features and implementation strategies, and standardizing development processes to ensure comparability. This part aims to directly assess the hands-on development experiences and the intrinsic differences in coding practices, development time, and initial code quality among Java, Kotlin, and Flutter.
\par
\textbf{Part II: SonarQube Code Inspection and Open Source Projects} - The second part of the methodology utilizes SonarQube, a tool for measuring code quality, to conduct an extensive analysis of existing open-source projects written in Java, Kotlin, and Dart. This includes a detailed setup of the SonarQube environment, a selection of projects based on predefined criteria, and systematic code inspections. The goal is to objectively evaluate and compare code quality in terms of maintainability, prevalence of code smells, and other quality metrics across projects that use these technologies.
\par
The dual perspective on software development practices provided by both parts, direct through application development and indirect through analysis of existing codebases, enriches the understanding of each framework's capabilities and limitations and enhances the reliability of the study by cross-verifying findings from practical development with empirical data from broader project analyses.
\par
By combining these methodologies, the research aims to deliver insightful conclusions that can guide developers in selecting the most suitable programming framework based on empirical evidence and practical experiences. The subsequent sections will detail each part of the methodology, explaining the processes, tools, and criteria used to ensure a thorough and unbiased evaluation of each development approach.
\subsection{Identical Mobile Application Development}
The present study outlines a methodology for investigating the efficacy of three programming frameworks, Java, Kotlin, and Dart (Flutter), by developing an identical Kanban board application. The investigation aims to evaluate each framework's development efficiency, usability, and initial code quality. The study provides a comprehensive account of the developmental process followed for each framework, ensuring that the functional parity of the application is maintained while adhering to the conversational practices of each programming language.
\subsubsection{Project Planning.}
The initial phase of our research project involved identifying an appropriate application to develop to assess which framework would be best suited for project development and maintenance. The application needed advanced features to achieve this objective while remaining relatively uncomplicated. Initially, an e-commerce application was proposed. However, after careful consideration, it was determined that the backend development required for such an application would be too time-consuming. Consequently, we opted for a To-do application to fulfill our research objectives of identifying a framework best suited for application development.
\par
In the next phase of our project development, we meticulously evaluated the features to include and the backend and database to use. After thorough consideration, we concluded that Firebase is the optimal choice for our backend. Firebase’s significantly reduced coding effort, thanks to its extensive range of pre-built features that seamlessly integrate into our project, primarily drove this decision. Moreover, Firebase offers two database options—Realtime and Firestore—and we selected Firestore for its superior performance and scalability.
\par
Once we settled on our database, we embarked on a user-centric approach to feature selection. We identified the features that best serve our project’s needs. The following features were chosen:
\begin{itemize}
\item	Kanban Board Visualization: A visually appealing layout representing tasks across stages—to-do, In Progress, and Completed.
\item	User Account Management includes user registration, login/logout, and the option to log in with Google.  
\item  	Task Management is adding new tasks, editing and modifying existing tasks, and moving tasks between different stages.
\item 	Time Tracking: This stopwatch feature allows users to track the time spent on tasks in the "In Progress" stage and pause the timer by moving tasks back to the To-Do stage.
\item 	Export and Share Functionality: Users can export their tasks as a CSV file and share them with others.
\item   Database Integration: We utilize the Firebase database to store and manage user data and tasks, enabling real-time updates and synchronization across all devices.
\end{itemize}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale = 0.85]{img/kanban_board.png}
    \caption{Planned view of Kanban board application. Designed by Figma}
    \label{fig:kanban_board}
\end{figure}

\par
Our next step was to create a detailed design for our application. After some consideration, we used the Figma application because of its widespread popularity in app and web development. Establishing a comprehensive feature plan and precise design before commencing the coding process is essential. With a clear objective in mind, we recognized the importance of avoiding improvisation and thus decided to prioritize the design phase before diving into coding.
\par
Following the design phase of our project, in which we utilized Figma to create a comprehensive plan for our application, we proceeded to make critical decisions regarding feature selection and the choice of database and backend service. With these decisions finalized, we were poised to embark on the project's development phase, beginning with the coding part. 
\begin{figure}[htbp]
    \centering
    \includegraphics[scale = 0.8]{img/flutter_app_str.png}
    \caption{Flutter version of the application’s project structuring}
    \label{fig:flutter_app_str}
\end{figure}
\subsubsection{Flutter Application Development}
We decided to begin with the Flutter application to ensure a smooth development process due to our familiarity with the framework. Our feature specifications and Figma designs were already in place, which made the process easier. BLOC \cite{bloc} was chosen for state management, which is highly regarded in the Flutter community for its reliability and ease of maintenance. Although it may require some practice and digging to get started, compared to other state management approaches like GetX \cite{getX} and Provider \cite{provider}, BLOC is known for its reliability and ease of maintaining advantages. It is used solely for the business logic of the application and state management, separating it from the presentation layer. The three main components of BLOC are Events, States, and Blocs. User interactions trigger Events sent to a Bloc, which processes them and performs any necessary logic, such as data fetching or computations. The Bloc then emits a new State based on the results, and the UI listens to these state changes to update itself accordingly. This architecture enhances maintainability and testability by decoupling the UI from the core business logic.

\par
It took us around 20 hours to complete the project, and the total number of files was 29. As the Figure \ref*{fig:flutter_app_str} shows, the project was divided into directories. The project is organized into several directories: blocks contain BLoC components for authentication and task management, managing logic, events, and states; constants directory includes global constants and routing configurations; models define the task data model; presentation houses UI screens for authentication, a dashboard with various widgets for displaying tasks based on their status, and a history page for viewing completed tasks or activity logs; repositories manage data operations related to authentication and tasks, interfacing with databases or APIs; services includes functionalities such as exporting task data to CSV files; and widgets provides general-purpose UI components used across the application. The 'main.dart' file acts as the app's entry point, setting up the environment and the root widget tree. The project structure suggests focusing on modularity and clean architecture to facilitate maintenance and scalability. While working on this project, we tried to follow the clean architecture mentioned in the book \cite{martin2009clean} by Robert Cecil Martin (also known as Uncle Bob).
\subsubsection{Kotlin Application Development} 
We developed a Kotlin-based Kanban board application after completing our initial Flutter project. Following our successful Flutter project, we adopted Kotlin as our first choice for Android Native development. Our Kotlin project was designed to support a Kanban board application and consisted of 26 .kt files and 30 .xml files. The development process took approximately 24 hours, primarily due to my limited familiarity with the Kotlin Application Development.
However, despite these challenges, we leveraged the Model-View-ViewModel (MVVM) architecture to enhance maintainability and facilitate a clear separation of concerns. The MVVM \cite{Sewak_2023} architecture enabled us to segregate user interface logic from business logic, with ViewModel managing the UI-related data that can persist through configuration changes. At the same time, View handled the layout and display, and Model managed the data and business logic.
\begin{figure}[htbp]
    \centering
    \includegraphics[scale = 0.8]{img/kotlin_project_struct.png}
    \caption{Kotlin version of the application’s project structuring}
    \label{fig:kotlin_project_struct}
\end{figure}
\par
As it is shown in Figure \ref*{fig:kotlin_project_struct}, we organized the Kotlin code into intuitive packages: app for foundational classes like AppConstant and BaseActivity, data.response for handling data models like TaskResponse and UserResponse, and repository for data management, particularly with an AuthRepository to interface with authentication mechanisms. User interfaces were built under the ‘ui’ package, divided into sub-packages like ‘completetask’, ‘home’, and ‘login’, each containing activities and adapters for respective functionalities. Utility classes were stored in utils, with error handling and resource management centralized for accessibility.
\par
The resource directory was meticulously structured with drawable resources for UI elements, layout XML files for defining user interfaces, and values for managing themes, strings, and dimensions, ensuring a consistent and visually appealing design. The AndroidManifest.xml was crucial in determining the application's configuration and permissions.
\par
This Kotlin project, despite its inherent challenges, demonstrated the robustness of MVVM in Android development. It enabled a clean separation of business logic from the front end, improving the application's testability and scalability. Our design approach was heavily influenced by the clean architecture principles outlined in Robert C. Martin's works \cite{martin2009clean}, focusing on creating a scalable, maintainable structure that could efficiently accommodate future enhancements and changes.

\subsubsection{Java Application Development}
\begin{figure}[htbp]
    \centering
    \includegraphics[scale = 0.8]{img/java_project_struct.png}
    \caption{Java version of the application’s project structuring}
    \label{fig:java_project_struct}
\end{figure}
\par
Upon completing the Kotlin project, we focused on developing the Android application's Java version. The project structure had to remain consistent with the Kotlin version, and to achieve this, we implemented advanced decompiling tools that facilitated the conversion of Kotlin code into Java. This approach significantly streamlined our development process, as the tools automatically translated the Kotlin code into Java, maintaining a similar project structure and functionality as outlined in the Kotlin project.
\par
Compile tools proved remarkably effective given the tight project timeline and the need to expedite development without sacrificing code quality. By directly converting the Kotlin code to Java, we saved considerable development time and effort, allowing us to focus on refining the Java application and ensuring its robustness and reliability. The entire process of translating and adjusting the Java project took approximately four hours.
\par
The Figure \ref{fig:java_project_struct} indicates that the resultant Java project was structured similarly to the Kotlin version. It included the same packages, such as "app" for core application setups such as AppConstant and BaseActivity, "data.response" for data models (TaskResponse, UserResponse), and "repository" for handling data operations (AuthRepository). The user interface was organized under the "ui" package with sub-packages for different functionalities, mirroring the Kotlin setup. Furthermore, utility classes were organized under "utils," and resources were meticulously arranged as in the Kotlin project.
\par
Compression tools ensured consistency between the two projects and enhanced maintainability and scalability, thanks to the established structure and the robustness of the MVVM architecture used in both the Kotlin and Java projects. In conclusion, the strategic use of decompile tools proved essential in meeting our project deadlines efficiently while maintaining high code quality standards and application performance.
